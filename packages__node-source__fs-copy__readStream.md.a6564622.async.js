(self["webpackChunkFE_note"]=self["webpackChunkFE_note"]||[]).push([[5881],{1422:n=>{"use strict";n.exports={}},3859:(n,e,t)=>{"use strict";t.r(e),t.d(e,{default:()=>s});const s={}},950:(n,e,t)=>{"use strict";t.r(e),t.d(e,{default:()=>i});var s=t(7294),o=t(6584),r=t(2196);t(3859);const i=n=>(s.useEffect((()=>{null!==n&&void 0!==n&&n.location.hash&&o.AnchorLink.scrollToAnchor(decodeURIComponent(n.location.hash.slice(1)))}),[]),s.createElement(s.Fragment,null,s.createElement("div",{className:"markdown"},s.createElement(r.Z,{code:"import { EventEmitter } from 'events';\nimport * as fs from 'fs';\nimport { resolve } from 'path';\n\ninterface StreamOptions {\n  flags?: string;\n  encoding?: string;\n  fd?: number;\n  mode?: number;\n  autoClose?: boolean;\n  /**\n   * @default false\n   */\n  emitClose?: boolean;\n  start?: number;\n  end?: number;\n  highWaterMark?: number;\n}\n\n/**\n * @description \u6587\u4ef6\u53ef\u8bfb\u6d41\n */\n\nexport class ReadStream extends EventEmitter {\n  flags: string;\n  encoding: string;\n  fd: number;\n  mode: number;\n  autoClose: boolean;\n  emitClose: boolean;\n  start: number;\n  end: number;\n  highWaterMark: number;\n  pos: number;\n  flowing: boolean;\n\n  constructor(public path: string, options?: StreamOptions) {\n    super();\n\n    this.flags = options?.flags ?? 'r';\n    this.encoding = options?.encoding ?? 'buffer';\n    this.mode = options?.mode ?? 0o666;\n    this.autoClose = options?.autoClose ?? true;\n    this.emitClose = options?.emitClose ?? false;\n    this.start = options?.start ?? 0;\n    this.end = options?.start;\n    this.highWaterMark = options?.highWaterMark ?? 64 * 1024;\n    //\u8bb0\u5f55\u8bfb\u53d6\u504f\u79fb\u91cf\n    this.pos = 0;\n    this.flowing = false;\n\n    this.on('newListener', (type) => {\n      console.log(type);\n      if (type === 'data') {\n        this.read();\n      }\n    });\n    this.open();\n  }\n\n  open() {\n    fs.open(this.path, this.flags, this.mode, (err, fd) => {\n      if (err) {\n        return this.emit('error', err);\n      }\n      this.fd = fd;\n      this.flowing = true;\n      this.emit('open', fd);\n    });\n  }\n\n  read() {\n    if (typeof this.fd !== 'number') {\n      return this.once('open', this.read);\n    }\n    const buffer = Buffer.alloc(this.highWaterMark);\n    const readLength = this.end\n      ? Math.min(this.end - this.pos + 1, this.highWaterMark)\n      : this.highWaterMark;\n\n    fs.read(\n      this.fd,\n      buffer,\n      0,\n      readLength,\n      this.pos,\n      (err, bytesRead, buffer) => {\n        if (err) return this.emit('error', err);\n\n        if (bytesRead) {\n          this.pos += bytesRead;\n          this.emit('data', buffer.slice(0, bytesRead));\n          if (this.flowing) {\n            this.read();\n          }\n        } else {\n          this.emit('end');\n          if (this.autoClose) {\n            fs.close(this.fd, () => this.emit('close'));\n          }\n        }\n      },\n    );\n  }\n  pipe(ws: fs.WriteStream) {\n    this.on('data', (data) => {\n      const flag = ws.write(data);\n      console.log('flag', flag);\n      if (!flag) {\n        this.pause();\n      }\n    });\n    ws.on('drain', () => {\n      console.log('write drain');\n      this.resume();\n    });\n  }\n  pause() {\n    this.flowing = false;\n  }\n  resume() {\n    this.flowing = true;\n    this.read();\n  }\n}\n\nconst rs = new ReadStream(resolve(__dirname, 'copy.txt'), {\n  highWaterMark: 3,\n});\n\nconst chunkData = [];\n\nrs.on('open', (fd) => {\n  console.log(fd, 'read');\n});\nrs.on('data', (chunk) => {\n  rs.pause();\n  setTimeout(() => {\n    console.log('\u89e6\u53d1\u6682\u505c\u6062\u590d');\n    rs.resume();\n  }, 10);\n  chunkData.push(chunk);\n});\n\nrs.on('close', () => {\n  console.log(chunkData.join(), 'read source');\n});",lang:"ts"}))))}}]);